<!DOCTYPE html> <html>
<head> 

<style>
pre {
    background-color: #F5F5F5;
	border: 5px solid #8e9baf;
    display: inline-block;
	height: 500px;
    width: 100%;
    overflow: auto;
    background-color: #eeeeee;
	text-align: left;
	padding-left: 3px;
	font-size: 125%;
}
</style>


<script>
//http://www.somethinghitme.com/2013/01/09/creating-a-canvas-platformer-tutorial-part-one/
//for chatroom server: https://vijayannadi.wordpress.com/tutorials/sample-chat-app-using-nodejs-socketio/
//another link: http://psitsmike.com/2011/10/node-js-and-socket-io-multiroom-chat-tutorial/
var up = 1;
var down = 2;
var left = 3;
var right = 4;

var xDir;
var yDir;

var dx = 5;
var dy = 20;

var startM = 0;
var endM = 12;
var countSpeed = 0;
var mapWorlds = {};

var world1 = [
	//40 width
	//10 height
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7],
	[0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	[1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
	[1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
	
];

var bound = [
	[],
	[],
	[],
	[],
	[],
	[],
	[],
	[],
	[],
	[]
];

var mainImg = new Image();
mainImg.src = "http://www.clker.com/cliparts/X/9/P/m/2/g/transparent-red-circle-md.png";
var mainImgRad = 25;


var player = {
	//not centered
	width: 50,
	height: 50,
	x: 50,
	y: 350,
	speed: 3,
	velX: 0,
	velY: 0,
	jumping: false,
	grounded: false,
	move: true
};

var gravity = 0.3;
var friction = 0.9;

var pause = true;

var box = 1;
var spike = 2;
var air = 3;
var finish = 4;
    
var started = false;
var lose = false;
/*
var jumpD = [];
var jumpDX = [];
var jumpCounter =0;
var canJump = true;
*/

var keys = [];
function start() {
	window.addEventListener("keydown", keyDown);
	window.addEventListener("keyup", keyUp);
	//document.getElementById("myCanvas").addEventListener("mousemove", mouseMove);
	//document.getElementById("myCanvas").addEventListener("mousedown", mouseDown);
	
	
	
	for (var i = 0; i < world1.length; i++) {
		for (var j = 0; j < world1[i].length; j++) {
			if (world1[i][j] == 1) {

				bound[i].push({
					x: j*50,
					y: i*50,
					width: 50,
					height: 50,
					type: box
				});
			} else if (world1[i][j] == 4) {
				bound[i].push({
					x: j*50,
					y: i*50,
					width: 50,
					height: 50,
					type: spike
				});
			} else if (world1[i][j] == 7) {
               bound[i].push({
                   x: j*50,
                   y: i*50,
                   width: 50,
                   height: 50,
                   type: finish
               }) 
            } else {
				bound[i].push({
					type: air
				});
			}
		}
	}
	
	
	onTick();
	//perSec();

}

function mouseDown(e) {

}

function mouseMove(e) {

}

function keyUp(e) {
	keys[e.keyCode] = false;
}

function keyDown(e) {
    //console.log(started);
    if (started == false) {
            pause = false;
            started = true;
        
    }
	keys[e.keyCode] = true;
	
	if (keys[80]) {
        //P
		pause = !pause;
		//console.log("pause: " + pause);
	}
    
    if (keys[32]) {
        //SPACE 
        if (lose) {
            resetGame();
        }
    }
}
	
	
function onTick() {
	window.setTimeout(onTick, 20);
	
	drawScreen();
}
	
	
	
function perSec() {

	window.setTimeout(perSec, 1000);
	
	//startM++;
	//endM++;
}

function colCheck(shapeA, shapeB) {
    // get the vectors to check against
    var vX = (shapeA.x + (shapeA.width / 2)) - (shapeB.x + (shapeB.width / 2));
    var vY = (shapeA.y + (shapeA.height / 2)) - (shapeB.y + (shapeB.height / 2));
        // add the half widths and half heights of the objects
    var hWidths = (shapeA.width / 2) + (shapeB.width / 2);
    var hHeights = (shapeA.height / 2) + (shapeB.height / 2);
    var colDir = null;
 
    // if the x and y vector are less than the half width or half height, they we must be inside the object, causing a collision
    if (Math.abs(vX) < hWidths && Math.abs(vY) < hHeights) {         // figures out on which side we are colliding (top, bottom, left, or right)        
		var oX = hWidths - Math.abs(vX);         
		var oY = hHeights - Math.abs(vY);         
		if (oX >= oY) {
			if (vY > 0) {
				colDir = "t";
				shapeA.y += oY;
			} else {
				colDir = "b";
				shapeA.y -= oY;
			}
		} else {
			if (vX > 0) {
				colDir = "l";
				shapeA.x += oX;
			} else {
				colDir = "r";
				shapeA.x -= oX;
			}
		}
	}
    return colDir;
}

function checkSpike(triangle) {
	//TODO
	/*
			A
			*
		   / \
		  /	  \
		B *----* C
		y = mx + b
	*/
	//Slope of AB (m)
	var a = {
		x: triangle.x + triangle.width/2,
		y: triangle.y
	};
	
	var b = {
		x: triangle.x,
		y: triangle.y + triangle.height
	};
	
	var c = {
		x: triangle.x + triangle.width,
		y: triangle.y + triangle.height
	};
	
	var ab = {
		x: triangle.width/4 + b.x,
		y: triangle.height/2 + a.y
	};
	
	var ac = {
		x: triangle.width/4 + a.x,
		y: triangle.height/2 + a.y
	};
	
	//console.log(a.x + " " + a.y);  
	//console.log(b.x + " " + b.y);
	//console.log(c.x + " " + c.y);
	
	var rad = player.width/2;
	
	var x = Math.floor(player.x) + player.width/2;
	var y = Math.floor(player.y) + player.height/2;
	
	var aD = Math.floor((a.x - x) * (a.x - x) + (a.y - y) * (a.y - y));
	var bD = Math.floor((b.x - x) * (b.x - x) + (b.y - y) * (b.y - y));
	var cD = Math.floor((c.x - x) * (c.x - x) + (c.y - y) * (c.y - y));
	var abD = Math.floor((ab.x - x) * (ab.x - x) + (ab.y-y)*(ab.y-y));
	var acD = Math.floor((ac.x - x) * (ac.x - x) + (ac.y-y)*(ac.y-y));
	
	var rad2 = rad * rad;
	
	if (aD <= rad2 || bD <= rad2 || cD <= rad2 || abD <= rad2 || acD <= rad2) {
		//console.log((ab.x - x) + " " + (ab.y - y) + " " + player.x + " " + player.y);
		//console.log((ab.x) + " " + (ab.y) + " " + abD + " " + (player.x + 25) + " " + (player.y + 25));
		//console.log(((ab.x) * (ab.x-x) + (ab.y-y)*(ab.y-y)));
		console.log((ab.x) + " " + (player.x + 25) + " " + (ab.y) + " " + (player.y +25) + " " + triangle.x + " " + triangle.y);
        
        return true;
		/*
		var p1X;
		var p1Y;
		var p2X;
		var p2Y;
		
		var small = Math.min(Math.min(aD, bD), cD);
		var big = Math.max(Math.max(aD, bD), cD);
		var mid;		
		//console.log("ASD");
		if (small == aD) {
			p1X = a.x;
			p1Y = a.y;
			if (big == cD) {
				p2X = c.x;
				p2Y = c.y;
				mid = bD;
			} else if (big == bD) {
				p2X = b.x;
				p2Y = b.y;
				mid = cD;
			}
		} else if (small == bD) {
			p1X = b.x;
			p1Y = b.y;
			if (big == cD) {
				p2X = c.x;
				p2Y = c.y;
				mid = aD;
			} else if (big == aD) {
				p2X = a.x;
				p2Y = a.y;
				mid = cD;
			}
		} else if (small == cD) {
			p1X = c.x;
			p1Y = c.y;
			if (big == aD) {
				p2X = a.x;
				p2Y = a.y;
				mid = bD;
			}
			else if (big == bD) {
				p2X = b.x;
				p2Y = b.y;
				mid = aD;
			}
		}
		
		
		
		
		
		var slope = (p1Y - p2Y) / (p1X - p2X);
		var offset = p1Y - (p1X*slope);
		console.log(slope + " " + offset);
		if (findCircleLineIntersections(rad, player.x + rad, player.y + rad, slope, offset)) {
			console.log("Touched");
			pause = true;
		}
		*/
	}
    return false;
	/*
	var aSlope = Math.floor((a.y - b.y) / (a.x - b.x));
	//(b)
	var aOff = a.y - (a.x * aSlope); 
	//TODO fix offsets
	//slope of BC = 0
	var bOff = b.y;
	//slope of AC
	var cSlope = Math.floor((a.y - c.y) / (a.x - c.x));  
	//(b)
	var cOff = c.y - (c.x * cSlope);
	
	console.log(a.x + " *" + aSlope + " = " + aSlope*a.x + " vs " + a.y);
	//console.log(aOff + " " + bOff + " " + cOff);
	
	
		if (equation of the circle is less than all of the equations of the lines of the triangle) {
			then circle is inside triangle
		}
	
	
	//circle equation: (x-h)^2 + (y+k)^2 = r^2 
	//circle at (h, k)
	//var h = player.x;
	//var k = player.y;
	
	var lX = player.x;
	var lY = Math.floor(player.y) + player.height/2;
	
	var rX = player.x + player.width;
	var rY =  Math.floor(player.y) + player.height/2;
	
	var uX = player.x + player.width/2;
	var uY =  Math.floor(player.y) + player.height;
	
	
	console.log(aSlope + " * " + lX + " + " + aOff + " = " + (aSlope*lX+aOff) + " vs " + (lY));
	console.log(cSlope + " * " + lX + " + " + cOff + " =  "+ (cSlope*lX+cOff) + " vs " + lY);
	console.log(Math.floor(player.y) + " " + triangle.y);
	if ((aSlope*lX + aOff >= lY) && (cSlope*lX + cOff >= lY) && (bOff >= lY) && (Math.floor(player.y) == triangle.y)) {
		console.log("touch");
		pause = true;
	}
	
	if ((aSlope*rX + aOff >= rY) && (cSlope*rX + cOff >= rY) && (bOff >= rY) && (Math.floor(player.y) == triangle.y)) {
		console.log("touch");
		pause = true;
	}
	if ((aSlope*uX + aOff >= uY) && (cSlope*uX + cOff >= uY) && (bOff >= uY) && (Math.floor(player.y) == triangle.y)) {
		console.log("touch");
		pause = true;
	}
	*/
}

function findCircleLineIntersections(r, h, k, m, n) {
    // circle: (x - h)^2 + (y - k)^2 = r^2
    // line: y = m * x + n
    // r: circle radius
    // h: x value of circle centre
    // k: y value of circle centre
    // m: slope
    // n: y-intercept

    // get a, b, c values
    var a = 1 + Math.sqrt(m);
    var b = -h * 2 + (m * (n - k)) * 2;
    var c = Math.sqrt(h) + Math.sqrt(n - k) - Math.sqrt(r);

    // get discriminant
    var d = Math.sqrt(b) - 4 * a * c;
    if (d >= 0) {
        // insert into quadratic formula
		/*
        var intersections = [
            (-b + Math.sqrt(Math.sqrt(b) - 4 * a * c)) / (2 * a),
            (-b - Math.sqrt(Math.sqrt(b) - 4 * a * c)) / (2 * a)
        ];
        if (d == 0) {
            // only 1 intersection
            return true;
        }*/
        return true;
    }
    // no intersection
    return false;
}

function win() {
    pause = true;
    setTimeout(function() {window.alert("Nice You Finished! Want to make a map of your own? Talk to the creator for details. (Credit will go to you)");}, 100);
}
    
function gameOver() {
    pause = true;
    lose = true;
    setTimeout(function() {
        window.alert("LOSE! Press SPACE to restart");
    }, 100);
   
}
    
function resetGame() {
    player = {
        //not centered
        width: 50,
        height: 50,
        x: 50,
        y: 350,
        speed: 3,
        velX: 0,
        velY: 0,
        jumping: false,
        grounded: false,
        move: true
    };
    pause = true;
    started = false;
    lose = false;
    countSpeed = 0;
}
    
	function drawScreen() {
		var canvas = document.getElementById("myCanvas");
		var context = canvas.getContext("2d");
		var height = canvas.height;
		var width = canvas.width;
		var div = document.getElementById("myDiv");
		var width = canvas.width;
		var height = canvas.height;
		
		
		if (!pause) {
			 if (keys[32] || keys[87]) {
				// up arrow or space
			  if(!player.jumping){
			   player.jumping = true;
			   player.velY = -player.speed*2;
			  }
			}
			if (keys[68]) {
				// right arrow
				if (player.velX < player.speed) {             
					player.velX++;         
				 }     
			}     
			if (keys[65]) {         
				// left arrow         
				if (player.velX > -player.speed) {
					player.velX--;
				}
			}
			
		 
			player.velX *= friction;
		 
			player.velY += gravity;
		 
			player.x += player.velX;
			player.y += player.velY;
			
			//console.log(player.velX);
			
            if (Math.trunc(player.velX) == 0) {
				player.move = false;
				
			} else{
				player.move = true;
			}
			
			if (player.x >= width-player.width) {
				player.x = width-player.width;
			} else if (player.x <= 0) {  
				//GAMEOVER
                //player touches the back
				player.x = 0;   
				//console.log("LOSE");
				gameOver();
			}    
		  
			//falls down into hole
			if(player.y >= height){
			
				//GAMEOVER
				gameOver();
				/*
				player.y = height - player.height;
				//console.log("TOUCHED");
				player.jumping = false;
				*/
			} 
		
			player.grounded = false;
			
			if (countSpeed > 75) {
                startM++;
                endM++;
                console.log(startM);
				
			}
			
			for (var i = 0; i < bound.length; i++) {
				for (var j = 0; j < bound[i].length; j++) {
					if (bound[i][j] != null) {
						if(bound[i][j].type == box) {
							var dir = colCheck(player, bound[i][j]);
					 
							if (dir === "l" || dir === "r") {
								player.velX = 0;
								player.jumping = false;
							} else if (dir === "b") {
								player.grounded = true;
								player.jumping = false;
							} else if (dir === "t") {
								player.velY *= -1;
							}
						} else if (bound[i][j].type == spike) {
							if (checkSpike(bound[i][j])) {
                                gameOver();
                            }
						} else if (bound[i][j].type == finish) {
                            var dir = colCheck(player, bound[i][j]);
					 
							if (dir != null) {
                                win();
							}
                        }
					}
				}
			}
		 
			if(player.grounded){
				 player.velY = 0;
			}
		}
	
		
		
		context.clearRect(0, 0, 500, 500);
		
		context.fillStyle = "#ffffff";
		context.fillRect(0, 0, canvas.width, canvas.height);
		//alert("2");
		
		context.strokeStyle = "#000000";
		context.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
		
		
		
		for (var i = 0; i < world1.length; i++) {
			for (var j = 0; j < world1[i].length; j++) {
				
				var img = new Image();
				var pix = world1[i][j];
				if (pix == 1) {
					img.src = "https://i.stack.imgur.com/ZcPaO.png";
					context.drawImage(img, j*50 - countSpeed, i*50, 50, 50);
					bound[i][j].x = j*50-countSpeed;
				} else if (pix == 4) {
					img.src = "https://upload.wikimedia.org/wikipedia/commons/thumb/7/7f/Green_equilateral_triangle_point_up.svg/886px-Green_equilateral_triangle_point_up.svg.png";
					context.drawImage(img, j*50-countSpeed, i*50, 50, 50);
					bound[i][j].x = j*50 - countSpeed;
				} else if (pix == 7) {
                    img.src = "https://img.buzzfeed.com/buzzfeed-static/static/2016-02/5/12/enhanced/webdr10/enhanced-buzz-19784-1454693031-4.jpg";
                    context.drawImage(img, j*50-countSpeed, i*50, 50, 50);
                    bound[i][j].x = j*50-countSpeed;
                }
			}
		}
		if (!pause) {
			//console.log(player.move);
			if (player.move == false) {
				player.x -= 1.5;
			}
			//console.log(player.move);
			for (var i = 0; i < bound.length; i++) {
				bound[i].x -= countSpeed;
			}
			countSpeed += 1.5;
		  
            
		}
		
		//character
		context.drawImage(mainImg, player.x, player.y, player.width, player.height);
		//console.log(mainImg.height);
	}
	
	
	
	
	
	
	


</script>
</head>
<body onload="start()" >



<div id="myDiv">
<canvas id="myCanvas" width="500" height="500">
Your browser does not support the HTML5 canvas tag.
</canvas></div>


</body>
</html>