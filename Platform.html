<!DOCTYPE html> <html>
<head> 

<style>
pre {
    background-color: #F5F5F5;
	border: 5px solid #8e9baf;
    display: inline-block;
	height: 500px;
    width: 100%;
    overflow: auto;
    background-color: #eeeeee;
	text-align: left;
	padding-left: 3px;
	font-size: 125%;
}
</style>

<script src="https://www.gstatic.com/firebasejs/4.2.0/firebase.js"></script>
    
<script>
//link https://firebase.google.com/docs/reference/js/firebase.database.DataSnapshot#forEach    
    
    
 var config = {
    apiKey: "AIzaSyCZjt0SMXe12qPYjxIPRXMqw4LGXCcy37w",
    authDomain: "platform-c316b.firebaseio.com/.firebaseapp.com",
    databaseURL: "https://platform-c316b.firebaseio.com/",
    storageBucket: "platform-c316b.appspot.com"
  };
firebase.initializeApp(config);

// Get a reference to the database service
var database = firebase.database();
    
    
var leaderboard = database.ref().child("Leaderboard");    
var childMap = {};
var childArr = [];
    
function data() {
    println("Leaderboard: ", "green");
    leaderboard.once("value")
        .then(function(snapshot) {
            snapshot.forEach(function(childSnapShot) {
                var key = childSnapShot.key;
                var childData = childSnapShot.val();
                
                //console.log(key + " " + childData);
                if (childArr.indexOf(childData) != -1) {
                    //already exists
                    childMap[childData].push(key);
                } else {
                    childArr.push(childData);
                    //console.log(childArr.length);
                    childMap[childData] = new Array();
                    childMap[childData].push(key);
                }
            });
            
            printLeaderboard();
        });
        
}    

function printLeaderboard() {
    
    childArr.sort(function(a, b){return b - a});
    for (var i = 0; i < childArr.length; i++) {
        var arr = childMap[childArr[i]];
        for (var j = 0; j < arr.length; j++) {
            println("  " + (i+j+1) + ". " + arr[j] + " " + childArr[i]);
        }
    }
}
    
function addToLeaderboard(n, p) {
    //leaderboard.push(n);
    var updates = {};
    updates['/Leaderboard/' + n] = p;
    database.ref().update(updates);
    
    if (childArr.indexOf(p) != -1) {
        //already exists
        childMap[p].push(n);
    } else {
        childArr.push(p);
        //console.log(childArr.length);
        childMap[p] = new Array();
        childMap[p].push(n);
    }
    
    println("");
    println("");
    println("NEW Leaderboard", "red");
    
    printLeaderboard();
     
}
    
    
    
    
    
    
    
//http://www.somethinghitme.com/2013/01/09/creating-a-canvas-platformer-tutorial-part-one/
//for chatroom server: https://vijayannadi.wordpress.com/tutorials/sample-chat-app-using-nodejs-socketio/
//another link: http://psitsmike.com/2011/10/node-js-and-socket-io-multiroom-chat-tutorial/
var up = 1;
var down = 2;
var left = 3;
var right = 4;

var points = 0;    

var xDir;
var yDir;

var dx = 5;
var dy = 20;

var startM = 0;
var endM = 12;
var countSpeed = 0;
var mapWorlds = {};

var world1 = [
	//40 width
	//10 height
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 1, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7],
	[0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 6, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	[1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
	[1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
	
];

var bound = [
	[],
	[],
	[],
	[],
	[],
	[],
	[],
	[],
	[],
	[]
];

var mainImg = new Image();
mainImg.src = "http://www.clker.com/cliparts/X/9/P/m/2/g/transparent-red-circle-md.png";
var mainImgRad = 25;


var player = {
	//not centered
	width: 50,
	height: 50,
	x: 50,
	y: 350,
	speed: 3,
	velX: 0,
	velY: 0,
	jumping: false,
	grounded: false,
	move: true
};

var gravity = 0.3;
var friction = 0.9;

var pause = true;

var box = 1;
var spike = 2;
var air = 3;
var finish = 4;
var coin = 5;
    
var tCoins = [];
    
var started = false;
var lose = false;
var win = false;
/*
var jumpD = [];
var jumpDX = [];
var jumpCounter =0;
var canJump = true;
*/

var keys = [];
function start() {
	alert("IMPORTANT!!! Make sure everytime you lose or win, press space after the alert goes away");
    data();
	window.addEventListener("keydown", keyDown);
	window.addEventListener("keyup", keyUp);
	//document.getElementById("myCanvas").addEventListener("mousemove", mouseMove);
	//document.getElementById("myCanvas").addEventListener("mousedown", mouseDown);
	
	
	
	for (var i = 0; i < world1.length; i++) {
		for (var j = 0; j < world1[i].length; j++) {
            var xpos = j*50;
            var ypos = i*50;
            var w = 50;
            var h = 50;
                
			if (world1[i][j] == 1) {

				bound[i].push({
					x: xpos,
					y: ypos,
					width: w,
					height: h,
					type: box
				});
			} else if (world1[i][j] == 4) {
				bound[i].push({
					x: xpos,
					y: ypos,
					width: w,
					height: h,
					type: spike
				});
			} else if (world1[i][j] == 7) {
               bound[i].push({
                   x: xpos,
                   y: ypos,
                   width: w,
                   height: h,
                   type: finish
               }) 
            } else if (world1[i][j] == 6) {
                bound[i].push({
                    x: xpos,
                    y: ypos,
                    width: w,
                    height: h,
                    type: coin
                })
            } else {
				bound[i].push({
					type: air
				});
			}
		}
	}
	
	
	onTick();
	//perSec();

}

function mouseDown(e) {

}

function mouseMove(e) {

}

function keyUp(e) {
	keys[e.keyCode] = false;
}

function keyDown(e) {
    //console.log(started);
    if (started == false) {
            pause = false;
            started = true;
            keys[87] = false;
            keys[68] = false;
            keys[65] = false;
    }
	keys[e.keyCode] = true;
	
	if (keys[80]) {
        //P
		pause = !pause;
		//console.log("pause: " + pause);
	}
    
    if (keys[32]) {
        //SPACE 
        //console.log(lose + " " + win);
        if (lose || win) {
            resetGame();
        }
    }
}
	
	
function onTick() {
	window.setTimeout(onTick, 20);
	
	drawScreen();
}
	
function perSec() {

	window.setTimeout(perSec, 1000);
	
	//startM++;
	//endM++;
}

function colCheck(shapeA, shapeB) {
    // get the vectors to check against
    var vX = (shapeA.x + (shapeA.width / 2)) - (shapeB.x + (shapeB.width / 2));
    var vY = (shapeA.y + (shapeA.height / 2)) - (shapeB.y + (shapeB.height / 2));
        // add the half widths and half heights of the objects
    var hWidths = (shapeA.width / 2) + (shapeB.width / 2);
    var hHeights = (shapeA.height / 2) + (shapeB.height / 2);
    var colDir = null;
 
    // if the x and y vector are less than the half width or half height, they we must be inside the object, causing a collision
    if (Math.abs(vX) < hWidths && Math.abs(vY) < hHeights) {         // figures out on which side we are colliding (top, bottom, left, or right)        
		var oX = hWidths - Math.abs(vX);         
		var oY = hHeights - Math.abs(vY);         
		if (oX >= oY) {
			if (vY > 0) {
				colDir = "t";
				shapeA.y += oY;
			} else {
				colDir = "b";
				shapeA.y -= oY;
			}
		} else {
			if (vX > 0) {
				colDir = "l";
				shapeA.x += oX;
			} else {
				colDir = "r";
				shapeA.x -= oX;
			}
		}
	}
    return colDir;
}

function checkSpike(triangle) {
	//TODO
	/*
			A
			*
		   / \
		  /	  \
		B *----* C
		y = mx + b
	*/
	//Slope of AB (m)
	var a = {
		x: triangle.x + triangle.width/2,
		y: triangle.y
	};
	
	var b = {
		x: triangle.x,
		y: triangle.y + triangle.height
	};
	
	var c = {
		x: triangle.x + triangle.width,
		y: triangle.y + triangle.height
	};
	
	var ab = {
		x: triangle.width/4 + b.x,
		y: triangle.height/2 + a.y
	};
	
	var ac = {
		x: triangle.width/4 + a.x,
		y: triangle.height/2 + a.y
	};
	
	//console.log(a.x + " " + a.y);  
	//console.log(b.x + " " + b.y);
	//console.log(c.x + " " + c.y);
	
	var rad = player.width/2;
	
	var x = Math.floor(player.x) + player.width/2;
	var y = Math.floor(player.y) + player.height/2;
	
	var aD = Math.floor((a.x - x) * (a.x - x) + (a.y - y) * (a.y - y));
	var bD = Math.floor((b.x - x) * (b.x - x) + (b.y - y) * (b.y - y));
	var cD = Math.floor((c.x - x) * (c.x - x) + (c.y - y) * (c.y - y));
	var abD = Math.floor((ab.x - x) * (ab.x - x) + (ab.y-y)*(ab.y-y));
	var acD = Math.floor((ac.x - x) * (ac.x - x) + (ac.y-y)*(ac.y-y));
	
	var rad2 = rad * rad;
	
	if (aD <= rad2 || bD <= rad2 || cD <= rad2 || abD <= rad2 || acD <= rad2) {
		//console.log((ab.x - x) + " " + (ab.y - y) + " " + player.x + " " + player.y);
		//console.log((ab.x) + " " + (ab.y) + " " + abD + " " + (player.x + 25) + " " + (player.y + 25));
		//console.log(((ab.x) * (ab.x-x) + (ab.y-y)*(ab.y-y)));
		//console.log((ab.x) + " " + (player.x + 25) + " " + (ab.y) + " " + (player.y +25) + " " + triangle.x + " " + triangle.y);
        
        return true;
		/*
		var p1X;
		var p1Y;
		var p2X;
		var p2Y;
		
		var small = Math.min(Math.min(aD, bD), cD);
		var big = Math.max(Math.max(aD, bD), cD);
		var mid;		
		//console.log("ASD");
		if (small == aD) {
			p1X = a.x;
			p1Y = a.y;
			if (big == cD) {
				p2X = c.x;
				p2Y = c.y;
				mid = bD;
			} else if (big == bD) {
				p2X = b.x;
				p2Y = b.y;
				mid = cD;
			}
		} else if (small == bD) {
			p1X = b.x;
			p1Y = b.y;
			if (big == cD) {
				p2X = c.x;
				p2Y = c.y;
				mid = aD;
			} else if (big == aD) {
				p2X = a.x;
				p2Y = a.y;
				mid = cD;
			}
		} else if (small == cD) {
			p1X = c.x;
			p1Y = c.y;
			if (big == aD) {
				p2X = a.x;
				p2Y = a.y;
				mid = bD;
			}
			else if (big == bD) {
				p2X = b.x;
				p2Y = b.y;
				mid = aD;
			}
		}
		
		
		
		
		
		var slope = (p1Y - p2Y) / (p1X - p2X);
		var offset = p1Y - (p1X*slope);
		console.log(slope + " " + offset);
		if (findCircleLineIntersections(rad, player.x + rad, player.y + rad, slope, offset)) {
			console.log("Touched");
			pause = true;
		}
		*/
	}
    return false;
	/*
	var aSlope = Math.floor((a.y - b.y) / (a.x - b.x));
	//(b)
	var aOff = a.y - (a.x * aSlope); 
	//TODO fix offsets
	//slope of BC = 0
	var bOff = b.y;
	//slope of AC
	var cSlope = Math.floor((a.y - c.y) / (a.x - c.x));  
	//(b)
	var cOff = c.y - (c.x * cSlope);
	
	console.log(a.x + " *" + aSlope + " = " + aSlope*a.x + " vs " + a.y);
	//console.log(aOff + " " + bOff + " " + cOff);
	
	
		if (equation of the circle is less than all of the equations of the lines of the triangle) {
			then circle is inside triangle
		}
	
	
	//circle equation: (x-h)^2 + (y+k)^2 = r^2 
	//circle at (h, k)
	//var h = player.x;
	//var k = player.y;
	
	var lX = player.x;
	var lY = Math.floor(player.y) + player.height/2;
	
	var rX = player.x + player.width;
	var rY =  Math.floor(player.y) + player.height/2;
	
	var uX = player.x + player.width/2;
	var uY =  Math.floor(player.y) + player.height;
	
	
	console.log(aSlope + " * " + lX + " + " + aOff + " = " + (aSlope*lX+aOff) + " vs " + (lY));
	console.log(cSlope + " * " + lX + " + " + cOff + " =  "+ (cSlope*lX+cOff) + " vs " + lY);
	console.log(Math.floor(player.y) + " " + triangle.y);
	if ((aSlope*lX + aOff >= lY) && (cSlope*lX + cOff >= lY) && (bOff >= lY) && (Math.floor(player.y) == triangle.y)) {
		console.log("touch");
		pause = true;
	}
	
	if ((aSlope*rX + aOff >= rY) && (cSlope*rX + cOff >= rY) && (bOff >= rY) && (Math.floor(player.y) == triangle.y)) {
		console.log("touch");
		pause = true;
	}
	if ((aSlope*uX + aOff >= uY) && (cSlope*uX + cOff >= uY) && (bOff >= uY) && (Math.floor(player.y) == triangle.y)) {
		console.log("touch");
		pause = true;
	}
	*/
}

function circleCol(c1, c2) {
    var r1 = c1.width/2;
    var x1 = c1.x;
    var y1 = c1.y;
    
    var r2 = c2.width/2;
    var x2 = c2.x;
    var y2 = c2.y;
    
    var dis = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
    //assuming r1 == r2
    var r3 = r1 + r2;
    if (dis < (r3 * r3)) {
        return true;
    }
    return false;
}

/*
function findCircleLineIntersections(r, h, k, m, n) {
     circle: (x - h)^2 + (y - k)^2 = r^2
     line: y = m * x + n
     r: circle radius
     h: x value of circle centre
     k: y value of circle centre
     m: slope
     n: y-intercept

    // get a, b, c values
    var a = 1 + Math.sqrt(m);
    var b = -h * 2 + (m * (n - k)) * 2;
    var c = Math.sqrt(h) + Math.sqrt(n - k) - Math.sqrt(r);

    // get discriminant
    var d = Math.sqrt(b) - 4 * a * c;
    if (d >= 0) {
        // insert into quadratic formula
		
        var intersections = [
            (-b + Math.sqrt(Math.sqrt(b) - 4 * a * c)) / (2 * a),
            (-b - Math.sqrt(Math.sqrt(b) - 4 * a * c)) / (2 * a)
        ];
        if (d == 0) {
            // only 1 intersection
            return true;
        }
        return true;
    }
    // no intersection
    return false;
}*/

function gameWin() {
    pause = true;
    setTimeout(function() {window.alert("Nice You Finished! Want to make a map of your own? Talk to the creator for details. (Credit will go to you) (SPACE to continue)");}, 100);
    win = true;
}
    
function gameOver() {
    pause = true;
    lose = true;
    setTimeout(function() {
        window.alert("LOSE! Press SPACE to restart");
    }, 100);
   
}
    
function resetGame() {
    player = {
        //not centered
        width: 50,
        height: 50,
        x: 50,
        y: 350,
        speed: 3,
        velX: 0,
        velY: 0,
        jumping: false,
        grounded: false,
        move: true
    };
    pause = true;
    started = false;
    lose = false;
    win = false;
   
    countSpeed = 0;
    
    for (var i = 0; i < tCoins.length; i++) {
        var t1 = tCoins[i][0];
        var t2 = tCoins[i][1];
        //console.log(t1 + " " + t2);
        bound[t2][t1] = {
            x: t1*50,
            y: t2*50,
            width: 50,
            height: 50,
            type: coin
        };
        world1[t2][t1] = 6;
    }
    var name = prompt("You got " + points + " point(s)! Type your name in here to be on the leaderboard! ");
    
    if (name.replace(/\s/g, '') == "" || name == null) {
        alert("... okay anonymous...");
    } else {
        //add into firebase
        if (points < 10) {
            alert("oo... You don't have enough points to be on the leaderboard... tough...");
        } else {
            //console.log(name);
            addToLeaderboard(name, points);
        }
    }
     points = 0;
}
    
	function drawScreen() {
		var canvas = document.getElementById("myCanvas");
		var context = canvas.getContext("2d");
		var height = canvas.height;
		var width = canvas.width;
		var div = document.getElementById("myDiv");
		var width = canvas.width;
		var height = canvas.height;
		
		//console.log(player.velY);
		if (!pause) {
			 if (keys[87]) {
                 //console.log("UP");
				// up arrow or space
			  if(!player.jumping){
			   player.jumping = true;
			   player.velY = -player.speed*2;
			  }
			}
			if (keys[68]) {
				// right arrow
				if (player.velX < player.speed) {             
					player.velX++;         
				 }     
			}     
			if (keys[65]) {         
				// left arrow         
				if (player.velX > -player.speed) {
					player.velX--;
				}
			}
			
		 
			player.velX *= friction;
		 
			player.velY += gravity;
		 
			player.x += player.velX;
			player.y += player.velY;
			
			//console.log(player.velX);
			
            if (Math.trunc(player.velX) == 0) {
				player.move = false;
				
			} else{
				player.move = true;
			}
			
			if (player.x >= width-player.width) {
				player.x = width-player.width;
			} else if (player.x <= 0) {  
				//GAMEOVER
                //player touches the back
				player.x = 0;   
				//console.log("LOSE");
				gameOver();
			}    
		  
			//falls down into hole
			if(player.y >= height){
			
				//GAMEOVER
				gameOver();
				/*
				player.y = height - player.height;
				//console.log("TOUCHED");
				player.jumping = false;
				*/
			} 
		
			player.grounded = false;
			
			if (countSpeed > 75) {
                startM++;
                endM++;
                //console.log(startM);
				
			}
			
			for (var i = 0; i < bound.length; i++) {
				for (var j = 0; j < bound[i].length; j++) {
					if (bound[i][j] != null) {
                        //check if the boxes are in the canvas
						if(bound[i][j].type == box && bound[i][j].x < 600) {
							var dir = colCheck(player, bound[i][j]);
					 
							if (dir === "l" || dir === "r") {
								player.velX = 0;
								player.jumping = false;
							} else if (dir === "b") {
								player.grounded = true;
								player.jumping = false;
							} else if (dir === "t") {
								player.velY *= -1;
							}
						} else if (bound[i][j].type == spike && bound[i][j].x < 600) {
							if (checkSpike(bound[i][j])) {
                                gameOver();
                            }
						} else if (bound[i][j].type == finish) {
                            var dir = colCheck(player, bound[i][j]);
					 
							if (dir != null) {
                                gameWin();
							}
                        } else if (bound[i][j].type == coin) {
                            if (circleCol(player, bound[i][j])) {
                                points++;
                                bound[i][j] = {
                                    type: air
                                }
                                world1[i][j] = 0;
                                //stores the "touched" coin into an array so it can be put back into the game after reset
                                
                                tCoins.push(new Array(j, i));
                                
                                //console.log(points);
                            }
                        }
					}
				}
			}
		 
			if(player.grounded){
				 player.velY = 0;
			}
		}
	
		
		
		context.clearRect(0, 0, 500, 500);
		
		context.fillStyle = "#ffffff";
		context.fillRect(0, 0, canvas.width, canvas.height);
		//alert("2");
		
		context.strokeStyle = "#000000";
		context.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
		
		
		
		for (var i = 0; i < world1.length; i++) {
			for (var j = 0; j < world1[i].length; j++) {
				
				var img = new Image();
				var pix = world1[i][j];
                
                var x = j*50-countSpeed;
                var y = i*50;
                
				if (pix == 1) {
                    if (x < 600 && x > -100) {
                        img.src = "https://i.stack.imgur.com/ZcPaO.png";
					   context.drawImage(img, x, y, 50, 50);
                    }
					bound[i][j].x = x;
				} else if (pix == 4) {
                    if (x < 600 && x > -100) {
                        img.src = "https://upload.wikimedia.org/wikipedia/commons/thumb/7/7f/Green_equilateral_triangle_point_up.svg/886px-Green_equilateral_triangle_point_up.svg.png";
                        context.drawImage(img, x, y, 50, 50);
                    }
					bound[i][j].x = x;
				} else if (pix == 7) {
                    img.src = "https://img.buzzfeed.com/buzzfeed-static/static/2016-02/5/12/enhanced/webdr10/enhanced-buzz-19784-1454693031-4.jpg";
                    context.drawImage(img, x, y, 50, 50);
                    bound[i][j].x = x;
                } else if (pix == 6) {
                    //coin
                    if (x < 600 && x > -100) {
                        img.src = "http://rs1312.pbsrc.com/albums/t523/Super_Mario_Official/Collected%20Star%20Coin_zpsac55g8nr.gif~c200";
                        context.drawImage(img, x, y, 50, 50);
                    }
                    bound[i][j].x = x;
                }
			}
		}
		if (!pause) {
			//console.log(player.move);
			if (player.move == false) {
				player.x -= 1.5;
			}
			//console.log(player.move);
			for (var i = 0; i < bound.length; i++) {
				bound[i].x -= countSpeed;
			}
			countSpeed += 1.5;
		  
            
		}
		
		//character
		context.drawImage(mainImg, player.x, player.y, player.width, player.height);
		//console.log(mainImg.height);
	}
	
	
	
	function println(words, color) {
		var console = document.getElementById("console");
		var linebr = document.createElement("br");
		var span = document.createElement('span');
		span.style.color = color;
		console.append(span);
		span.append(words);
		span.append(linebr);
		console.scrollTop += 50;
	}
	
	


</script>
</head>
<body onload="start()" >


<table>
<tr height="100%">
<td width="50%">
<div id="myDiv">
<canvas id="myCanvas" width="500" height="500">
Your browser does not support the HTML5 canvas tag.
</canvas></div></td>


<td width="50%">
<div id="div2" style="text-align:center" >
<pre id="console"></pre></div>
</td>
</tr>
</table>


</body>
</html>
